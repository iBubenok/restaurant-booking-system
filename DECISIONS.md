# Архитектурные решения

Этот документ описывает ключевые технические решения, принятые при разработке системы бронирования столиков.

## Выбор технологий

### Python + FastAPI

**Почему выбрано:**
- FastAPI обеспечивает высокую производительность (comparable с Node.js и Go)
- Встроенная поддержка async/await для асинхронных операций
- Автоматическая генерация OpenAPI документации
- Pydantic для валидации данных
- Широкая экосистема библиотек для работы с БД и Kafka
- Быстрая разработка благодаря type hints

**Альтернативы:**
- Node.js + Express: хорошая производительность, но менее строгая типизация
- Go: отличная производительность, но более сложная разработка

### PostgreSQL

**Почему выбрано:**
- ACID транзакции критически важны для системы бронирования
- Надежность и стабильность
- Отличная поддержка в облачных платформах (Render, AWS RDS, etc.)
- Поддержка JSON типов для гибкости
- Встроенные механизмы для работы с датой/временем

**Альтернативы:**
- MySQL: похожие возможности, но PostgreSQL имеет более продвинутые фичи
- MongoDB: не подходит для транзакционных систем с высокими требованиями к консистентности

### Apache Kafka

**Почему выбрано:**
- De-facto стандарт для event-driven архитектуры
- Высокая производительность и масштабируемость
- Гарантии доставки сообщений
- Возможность replay событий
- Поддержка множества consumer групп

**Альтернативы:**
- RabbitMQ: проще в настройке, но менее производителен для high-throughput
- Redis Streams: легковесная альтернатива, но менее надежная для критичных систем
- AWS SQS/SNS: managed решение, но vendor lock-in

### SQLAlchemy (Async)

**Почему выбрано:**
- Поддержка асинхронных операций критична для производительности
- Зрелый и надежный ORM
- Отличная интеграция с Alembic для миграций
- Возможность писать как ORM-запросы, так и raw SQL при необходимости

### Alembic

**Почему выбрано:**
- Стандарт для миграций в Python/SQLAlchemy экосистеме
- Автогенерация миграций
- Version control для схемы БД
- Поддержка rollback

## Архитектурные решения

### Event-Driven Architecture

**Решение:** Разделение системы на API Service и Booking Service через Kafka.

**Преимущества:**
- Асинхронная обработка: API быстро отвечает клиенту, а обработка идет в фоне
- Масштабируемость: можно запускать несколько consumer'ов для параллельной обработки
- Отказоустойчивость: если worker падает, события не теряются
- Расширяемость: легко добавить новые consumer'ы для других задач (уведомления, аналитика)

**Недостатки:**
- Сложность инфраструктуры: требуется поддержка Kafka
- Eventual consistency: клиент не узнает сразу о результате
- Debugging сложнее из-за асинхронности

**Альтернативы:**
- Синхронная обработка: проще, но медленнее и менее масштабируема
- Job queue (Celery + Redis): легче настроить, но менее функционален

### Состояния бронирования

**Решение:** 4 состояния: CREATED → CHECKING_AVAILABILITY → CONFIRMED/REJECTED

**Почему:**
- Явное отслеживание процесса обработки
- Возможность понять, на каком этапе находится бронирование
- Легко добавить новые состояния (например, CANCELLED, COMPLETED)

**Альтернативы:**
- Только 2 состояния (PENDING/CONFIRMED/REJECTED): проще, но менее информативно
- Дополнительные состояния (PAYMENT_PENDING, CUSTOMER_NOTIFIED): для более сложных сценариев

### Проверка доступности

**Текущая логика:**
- Одно бронирование на ресторан + время
- Проверка только подтвержденных бронирований

**Ограничения:**
- Не учитывается количество столиков в ресторане
- Не учитывается продолжительность бронирования
- Упрощенная логика для демонстрации концепции

**Для production следует добавить:**
- Модель Table (столы) с capacity
- Модель TimeSlot для управления временными слотами
- Учет длительности бронирования (например, 2 часа)
- Проверка overlap'ов по времени
- Резервирование конкретного стола

### База данных

**Решение:** Одна общая БД для обоих сервисов

**Почему:**
- Упрощает разработку и деплой для тестового задания
- Нет дублирования данных
- Транзакционная консистентность

**Для production лучше:**
- Отдельные БД для каждого сервиса (microservices best practice)
- Event sourcing для синхронизации данных
- CQRS паттерн для разделения read/write моделей

## Тестирование

### Стратегия

**Выбор:** Unit-тесты для бизнес-логики + интеграционные тесты для API

**Покрытие:**
- BookingService: unit-тесты проверки доступности и обработки
- API endpoints: интеграционные тесты с тестовой БД
- Критичные пути: создание и получение бронирования

**Что не покрыто (для MVP):**
- Kafka integration тесты
- End-to-end тесты полного flow
- Performance тесты
- Chaos testing

### Тестовая БД

**Решение:** Отдельная БД `booking_db_test` для тестов

**Почему:**
- Изоляция тестов от dev/prod данных
- Можно безопасно создавать/удалять таблицы
- Параллельный запуск тестов

## CI/CD

### GitHub Actions

**Выбор:** GitHub Actions для CI

**Почему:**
- Нативная интеграция с GitHub
- Бесплатно для публичных репозиториев
- Простая конфигурация через YAML
- Поддержка matrix builds

**Pipeline:**
1. Линтинг (flake8)
2. Форматирование (black)
3. Unit + integration тесты
4. Docker build

**Что можно добавить:**
- Coverage reporting
- Security scanning (Snyk, Dependabot)
- Автоматический деплой на staging
- Performance benchmarks

### Render

**Выбор:** Render для деплоя

**Почему:**
- Простой deployment из Git репозитория
- Managed PostgreSQL
- Поддержка Workers (для Booking Service)
- Бесплатный tier для демонстрации
- HTTPS out of the box

**Ограничения:**
- Free tier засыпает при неактивности
- Ограничения по ресурсам
- Kafka нужно настраивать отдельно (Upstash)

**Альтернативы:**
- AWS: более гибко, но сложнее настройка
- Heroku: похож на Render, но дороже
- Railway: аналогичный функционал
- DigitalOcean App Platform: хороший баланс

## Компромиссы и технический долг

### Что упрощено для MVP

1. **Kafka в production**: требуется managed Kafka (Upstash, Confluent Cloud)
2. **Аутентификация**: нет JWT/OAuth для простоты
3. **Rate limiting**: нет защиты от злоупотреблений
4. **Валидация времени**: не проверяется, что booking_datetime в будущем
5. **Timezone**: используется UTC, нет конвертации в локальные timezone
6. **Уведомления**: не отправляются email/SMS клиентам
7. **Логирование**: базовое, нет structured logging или APM
8. **Мониторинг**: нет метрик, алертов, dashboards

### Возможные улучшения

#### Ближайшие улучшения

1. **Управление столами**
   ```python
   class Table:
       id: int
       restaurant_id: int
       capacity: int
       table_number: str
   ```

2. **Webhook уведомления**
   - Отправка события клиенту при изменении статуса
   - Retry logic с exponential backoff

3. **Pagination для списка бронирований**
   ```python
   GET /bookings?restaurant_id=1&page=1&limit=20
   ```

4. **Фильтры и поиск**
   ```python
   GET /bookings?status=CONFIRMED&date_from=2024-01-01
   ```

5. **Отмена бронирования**
   ```python
   DELETE /bookings/{id}
   ```

#### Долгосрочные улучшения

1. **Distributed tracing** (Jaeger, OpenTelemetry)
2. **Feature flags** для A/B тестирования
3. **GraphQL API** для гибких запросов
4. **Mobile app** поддержка
5. **Admin dashboard** для менеджмента
6. **Analytics service** для бизнес-метрик
7. **Recommendation engine** на основе истории

## Performance considerations

### Текущая производительность

- API latency: ~50-100ms (без Kafka)
- Database queries: simple SELECTs с индексами
- Kafka throughput: зависит от конфигурации

### Узкие места

1. **Database connection pool**:
   - Текущее значение: default
   - Рекомендация: настроить pool size в зависимости от load

2. **Kafka partitions**:
   - Текущее значение: 1
   - Рекомендация: несколько партиций для параллелизма

3. **Serialization**:
   - JSON достаточно для MVP
   - Для high-load: рассмотреть Protobuf/Avro

### Масштабирование

**Горизонтальное:**
- API Service: stateless, легко масштабируется
- Booking Service: можно запустить несколько workers
- PostgreSQL: master-replica для read scaling

**Вертикальное:**
- Увеличение ресурсов для БД
- Больше CPU для Kafka

**Caching:**
- Redis для часто запрашиваемых данных
- CDN для статики (если есть frontend)

## Безопасность

### Текущая ситуация

- Нет аутентификации
- Нет авторизации
- Базовая валидация входных данных (Pydantic)

### Что нужно добавить

1. **Authentication**: JWT tokens
2. **Authorization**: RBAC (role-based access control)
3. **Input sanitization**: защита от SQL injection (SQLAlchemy ORM помогает)
4. **Rate limiting**: защита от DDoS
5. **HTTPS**: обязательно в production
6. **Secrets management**: Vault или облачные решения
7. **Audit logging**: кто, что, когда изменил

## Заключение

Система реализована как MVP, демонстрирующий event-driven архитектуру и микросервисный подход. Для production использования требуется добавить функциональность по безопасности, мониторингу и бизнес-логике.

Архитектура спроектирована с учетом масштабирования и позволяет поэтапно добавлять новые возможности без значительного рефакторинга.
